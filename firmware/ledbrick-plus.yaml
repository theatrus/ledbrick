# Configure timezone here (change this to your timezone)
substitutions:
  sntp_timezone: "America/Los_Angeles"  # Examples: "Europe/London", "America/New_York", "Asia/Tokyo"

esphome:
  name: ledbrickplus
  friendly_name: ledbrickplus
  project:
    name: "ledbrick.plus"
    version: "__VERSION__"
  on_boot:
    - priority: 600
      then:
        - lambda: |-
            // Register all color text sensors with the scheduler
            id(main_scheduler).add_color_text_sensor(0, id(ch1_color));
            id(main_scheduler).add_color_text_sensor(1, id(ch2_color));
            id(main_scheduler).add_color_text_sensor(2, id(ch3_color));
            id(main_scheduler).add_color_text_sensor(3, id(ch4_color));
            id(main_scheduler).add_color_text_sensor(4, id(ch5_color));
            id(main_scheduler).add_color_text_sensor(5, id(ch6_color));
            id(main_scheduler).add_color_text_sensor(6, id(ch7_color));
            id(main_scheduler).add_color_text_sensor(7, id(ch8_color));
            ESP_LOGI("main", "Color text sensors registered with scheduler");
            
            // Force initial color sensor updates
            for (int i = 0; i < 8; i++) {
              std::string color = id(main_scheduler).get_channel_color(i);
              ESP_LOGI("main", "Initial color for channel %d: %s", i, color.c_str());
            }
            id(main_scheduler).update_color_sensors();
            
            // Register all light entities with the scheduler
            id(main_scheduler).add_light(0, id(lpwm1));
            id(main_scheduler).add_light(1, id(lpwm2));
            id(main_scheduler).add_light(2, id(lpwm3));
            id(main_scheduler).add_light(3, id(lpwm4));
            id(main_scheduler).add_light(4, id(lpwm5));
            id(main_scheduler).add_light(5, id(lpwm6));
            id(main_scheduler).add_light(6, id(lpwm7));
            id(main_scheduler).add_light(7, id(lpwm8));
            ESP_LOGI("main", "Light entities registered with scheduler");
            
            // Register all current controls with the scheduler
            id(main_scheduler).add_current_control(0, id(current_1));
            id(main_scheduler).add_current_control(1, id(current_2));
            id(main_scheduler).add_current_control(2, id(current_3));
            id(main_scheduler).add_current_control(3, id(current_4));
            id(main_scheduler).add_current_control(4, id(current_5));
            id(main_scheduler).add_current_control(5, id(current_6));
            id(main_scheduler).add_current_control(6, id(current_7));
            id(main_scheduler).add_current_control(7, id(current_8));
            ESP_LOGI("main", "Current controls registered with scheduler");
            
            // Register max current controls with the scheduler
            id(main_scheduler).add_max_current_control(0, id(max_current_1));
            id(main_scheduler).add_max_current_control(1, id(max_current_2));
            id(main_scheduler).add_max_current_control(2, id(max_current_3));
            id(main_scheduler).add_max_current_control(3, id(max_current_4));
            id(main_scheduler).add_max_current_control(4, id(max_current_5));
            id(main_scheduler).add_max_current_control(5, id(max_current_6));
            id(main_scheduler).add_max_current_control(6, id(max_current_7));
            id(main_scheduler).add_max_current_control(7, id(max_current_8));
            ESP_LOGI("main", "Max current controls registered with scheduler");

            // Configure temperature control
            // Fan connections
            id(main_scheduler).set_fan(id(fan_output));
            id(main_scheduler).set_fan_power_switch(id(fan_pwr));
            id(main_scheduler).set_fan_speed_sensor(id(fan_speed));


            // Configure temperature monitoring sensors
            id(main_scheduler).set_current_temp_sensor(id(temp_control_current));
            id(main_scheduler).set_target_temp_sensor(id(temp_control_target));
            id(main_scheduler).set_fan_pwm_sensor(id(temp_control_fan_pwm));
            id(main_scheduler).set_pid_error_sensor(id(temp_control_pid_error));
            id(main_scheduler).set_pid_output_sensor(id(temp_control_pid_output));
            id(main_scheduler).set_thermal_emergency_sensor(id(thermal_emergency));
            id(main_scheduler).set_fan_enabled_sensor(id(temp_control_fan_active));
            id(main_scheduler).set_enable_switch(id(temp_control_enable));
            
            ESP_LOGI("main", "Temperature control configuration complete");

            
    
    - priority: -100  # Run after all components are initialized
      then:
        - lambda: |-
            // Sync scheduler state with restored switch state
            bool switch_state = id(scheduler_enable_switch).state;
            bool scheduler_state = id(main_scheduler).is_enabled();
            if (switch_state != scheduler_state) {
              ESP_LOGI("main", "Syncing scheduler state: switch=%d, scheduler=%d", 
                       switch_state, scheduler_state);
              id(main_scheduler).set_enabled(switch_state);
            }
            
            // Sync astronomical projection state
            bool astro_switch_state = id(astronomical_projection_switch).state;
            bool astro_scheduler_state = id(main_scheduler).is_astronomical_projection_enabled();
            if (astro_switch_state != astro_scheduler_state) {
              ESP_LOGI("main", "Syncing astronomical projection: switch=%d, scheduler=%d", 
                       astro_switch_state, astro_scheduler_state);
              id(main_scheduler).set_astronomical_projection(astro_switch_state);
            }
            
                      
            // Set current channels to their maximum configured values at boot
            if (id(current_1) && id(max_current_1)) {
              float max_val = id(max_current_1)->state;
              id(current_1)->publish_state(max_val);
              ESP_LOGI("main", "Set current_1 to max value: %.2fA", max_val);
            }
            if (id(current_2) && id(max_current_2)) {
              float max_val = id(max_current_2)->state;
              id(current_2)->publish_state(max_val);
              ESP_LOGI("main", "Set current_2 to max value: %.2fA", max_val);
            }
            if (id(current_3) && id(max_current_3)) {
              float max_val = id(max_current_3)->state;
              id(current_3)->publish_state(max_val);
              ESP_LOGI("main", "Set current_3 to max value: %.2fA", max_val);
            }
            if (id(current_4) && id(max_current_4)) {
              float max_val = id(max_current_4)->state;
              id(current_4)->publish_state(max_val);
              ESP_LOGI("main", "Set current_4 to max value: %.2fA", max_val);
            }
            if (id(current_5) && id(max_current_5)) {
              float max_val = id(max_current_5)->state;
              id(current_5)->publish_state(max_val);
              ESP_LOGI("main", "Set current_5 to max value: %.2fA", max_val);
            }
            if (id(current_6) && id(max_current_6)) {
              float max_val = id(max_current_6)->state;
              id(current_6)->publish_state(max_val);
              ESP_LOGI("main", "Set current_6 to max value: %.2fA", max_val);
            }
            if (id(current_7) && id(max_current_7)) {
              float max_val = id(max_current_7)->state;
              id(current_7)->publish_state(max_val);
              ESP_LOGI("main", "Set current_7 to max value: %.2fA", max_val);
            }
            if (id(current_8) && id(max_current_8)) {
              float max_val = id(max_current_8)->state;
              id(current_8)->publish_state(max_val);
              ESP_LOGI("main", "Set current_8 to max value: %.2fA", max_val);
            }
            // Temperature sensors will be auto-discovered by scheduler during runtime
            
dashboard_import:
  package_import_url: github://theatrus/ledbrick/firmware/ledbrick-plus.yaml@master
  import_full_config: false


esp32:
  board: esp32-s3-devkitc-1
  flash_size: 8MB
  framework:
    type: esp-idf

# Enable logging
logger:
  level: DEBUG

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Ledbrickplus Fallback Hotspot"
    password: "gOqXwag35TIP"

captive_portal:
    
# Time synchronization with automatic timezone detection
time:
  - platform: homeassistant
    id: homeassistant_time
    on_time_sync:
      - logger.log: "Time synchronized via Home Assistant with timezone"
  - platform: sntp
    id: sntp_time
    servers:
      - pool.ntp.org
      - time.nist.gov
    # Use the configured timezone from substitutions
    timezone: ${sntp_timezone}
    on_time_sync:
      - logger.log: "Time synchronized via SNTP with timezone"

external_components:
  - source:
      type: git
      url: https://github.com/theatrus/mcpwm_unified
      ref: ebfcc0a743dfe2ccbdd7d582cc5bd97225980ee2
    components: [ mcpwm_unified ]
  - source:
      type: local
      path: components
    components: [ ledbrick_scheduler, ledbrick_web_server ]

# Our custom scheduler component with services
ledbrick_scheduler:
  id: main_scheduler
  channels: 8  # Full 8-channel configuration
  update_interval: 1s             # Update every second for smooth transitions
  time_source: homeassistant_time  # Prefer Home Assistant time for timezone support
  timezone: America/Los_Angeles     # Set your local timezone or leave default to match Home Assistant
  latitude: 37.7749                # San Francisco latitude (set to your location)
  longitude: -122.4194             # San Francisco longitude (set to your location)
  
  # Optional: Astronomical Time Projection
  # Projects sunrise/sunset times from the configured location to your local timezone
  # Example: Tahiti sunrise at 6:15 AM becomes 6:15 AM Pacific Time (with optional shift)
  astronomical_projection: false   # Enable to map remote sunrise/sunset to local time
  time_shift_hours: 0             # Optional: Additional shift in hours (+/- 12)
  time_shift_minutes: 0           # Optional: Additional shift in minutes (+/- 59)


status_led:
  pin: GPIO1

# Channel definitions using packages
packages:
  channel1: !include { file: packages/channel.yaml, vars: { channel_number: "1", pwm_pin: "GPIO5", current_pin: "GPIO6" } }
  channel2: !include { file: packages/channel.yaml, vars: { channel_number: "2", pwm_pin: "GPIO7", current_pin: "GPIO8" } }
  channel3: !include { file: packages/channel.yaml, vars: { channel_number: "3", pwm_pin: "GPIO9", current_pin: "GPIO10" } }
  channel4: !include { file: packages/channel.yaml, vars: { channel_number: "4", pwm_pin: "GPIO11", current_pin: "GPIO12" } }
  channel5: !include { file: packages/channel.yaml, vars: { channel_number: "5", pwm_pin: "GPIO13", current_pin: "GPIO14" } }
  channel6: !include { file: packages/channel.yaml, vars: { channel_number: "6", pwm_pin: "GPIO15", current_pin: "GPIO16" } }
  channel7: !include { file: packages/channel.yaml, vars: { channel_number: "7", pwm_pin: "GPIO17", current_pin: "GPIO18" } }
  channel8: !include { file: packages/channel.yaml, vars: { channel_number: "8", pwm_pin: "GPIO33", current_pin: "GPIO34" } }
  # LEDBrick Scheduler with Home Assistant services
  scheduler_services: !include packages/scheduler_services.yaml
  
  # Temperature control is now integrated into the scheduler component
  
  # ESP-IDF Web Server with REST API and Web Interface
  # WARNING: ESP32 only, uses ESP-IDF framework
  web_server_esp_idf: !include packages/web_server_esp_idf.yaml

output:
  # Fan PWM output - separate from channel packages
  - platform: mcpwm_unified
    id: fan_pwm
    pin: GPIO37
    frequency: 16000Hz
    inverted: true

switch:
  - platform: gpio
    pin: GPIO36
    name: "Fan power"
    id: fan_pwr
    restore_mode: RESTORE_DEFAULT_ON
    
  - platform: template
    name: "Temperature Control Enable"
    id: temp_control_enable
    icon: "mdi:thermostat"
    restore_mode: RESTORE_DEFAULT_ON
    lambda: |-
      return id(main_scheduler)->get_temperature_status().enabled;
    turn_on_action:
      - lambda: |-
          id(main_scheduler)->enable_temperature_control(true);
    turn_off_action:
      - lambda: |-
          id(main_scheduler)->enable_temperature_control(false);

fan:
  - platform: speed
    output: fan_pwm
    name: Fan Speed
    id: fan_output
    restore_mode: RESTORE_DEFAULT_ON


# Light entities are now defined in the channel package

# Status LED - WS2812 RGB on GPIO21
light:
  - platform: esp32_rmt_led_strip
    rgb_order: GRB
    pin: GPIO21
    num_leds: 1
    chipset: WS2812
    name: "Status LED"
    id: status_rgb_led
    effects:
      - pulse:
          name: "Pulse"
          transition_length: 1s
          update_interval: 1s
      - strobe:
          name: "Strobe"
          colors:
            - state: true
              brightness: 100%
              red: 100%
              green: 0%
              blue: 0%
              duration: 500ms
            - state: false
              duration: 250ms
      - addressable_rainbow:
          name: "Rainbow"
          speed: 10
          width: 50

# 1-Wire bus on GPIO41
one_wire:
  - platform: gpio
    pin: GPIO41
    id: onewire_bus

i2c:
  sda: GPIO3
  scl: GPIO4
  scan: true
  id: bus_a

sensor:
  - platform: ina2xx_i2c
    id: current_sensor
    model: INA228
    address: 0x40
    shunt_resistance: 0.005 ohm
    max_current: 20 A
    adc_range: 0
    update_interval: 5s
    current:
      name: "INA228 Current"
      id: ina228_current
    bus_voltage:
      name: "INA228 Bus Voltage" 
      id: ina228_bus_voltage
    charge: "INA228 Charge"

  - platform: pulse_counter
    pin: 
      number: GPIO35
      mode: INPUT
    unit_of_measurement: 'RPM'
    id: fan_speed
    name: Fan Speed
    accuracy_decimals: 0
    update_interval: 5s
    filters:
      - multiply: 0.5

  # Dallas temperature sensors (DS18B20) - auto-discovery enabled
  # ESPHome will automatically discover and create entities for all DS18B20 sensors
  - platform: dallas_temp
    update_interval: 5s
    one_wire_id: onewire_bus
    # Auto-discovery: omitting address makes ESPHome discover all sensors
    name: "Dallas Temperature"
    # Additional sensors can be configured manually if specific naming is needed:
    # - platform: dallas_temp
    #   one_wire_id: onewire_bus
    #   address: 0x1c0000031edd2a28
    #   name: "Heatsink Temperature"
    
  # Temperature control monitoring sensors
  - platform: template
    name: "Temperature Control Current"
    id: temp_control_current
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    lambda: |-
      return id(main_scheduler)->get_temperature_status().current_temp_c;
    update_interval: 5s
    
  - platform: template
    name: "Temperature Control Target"
    id: temp_control_target
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    lambda: |-
      return id(main_scheduler)->get_temperature_status().target_temp_c;
    update_interval: 5s
    
  - platform: template
    name: "Temperature Control Fan PWM"
    id: temp_control_fan_pwm
    unit_of_measurement: "%"
    accuracy_decimals: 1
    lambda: |-
      return id(main_scheduler)->get_temperature_status().fan_pwm_percent;
    update_interval: 5s
    
  - platform: template
    name: "Temperature Control PID Error"
    id: temp_control_pid_error
    unit_of_measurement: "°C"
    accuracy_decimals: 2
    internal: true
    lambda: |-
      return id(main_scheduler)->get_temperature_status().pid_error;
    update_interval: 5s
    
  - platform: template
    name: "Temperature Control PID Output"
    id: temp_control_pid_output
    unit_of_measurement: "%"
    accuracy_decimals: 1
    internal: true
    lambda: |-
      return id(main_scheduler)->get_temperature_status().pid_output;
    update_interval: 5s

# Binary sensors for temperature control status
binary_sensor:
  - platform: template
    name: "Thermal Emergency"
    id: thermal_emergency
    device_class: problem
    lambda: |-
      return id(main_scheduler)->get_temperature_status().thermal_emergency;
    
  - platform: template
    name: "Temperature Control Fan Active"
    id: temp_control_fan_active
    device_class: running
    lambda: |-
      return id(main_scheduler)->get_temperature_status().fan_enabled;




