# LEDBrick Scheduler Services Package
# Template-based Home Assistant integration for the LEDBrick Scheduler

api:
  services:
    # === Schedule Point Management ===
    
    # Set a schedule point for all 8 channels
    - service: set_schedule_point_8ch
      variables:
        time_minutes: int
        pwm_ch1: float
        pwm_ch2: float
        pwm_ch3: float
        pwm_ch4: float
        pwm_ch5: float
        pwm_ch6: float
        pwm_ch7: float
        pwm_ch8: float
        current_ch1: float
        current_ch2: float
        current_ch3: float
        current_ch4: float
        current_ch5: float
        current_ch6: float
        current_ch7: float
        current_ch8: float
      then:
        - lambda: |-
            std::vector<float> pwm_values = {pwm_ch1, pwm_ch2, pwm_ch3, pwm_ch4, pwm_ch5, pwm_ch6, pwm_ch7, pwm_ch8};
            std::vector<float> current_values = {current_ch1, current_ch2, current_ch3, current_ch4, current_ch5, current_ch6, current_ch7, current_ch8};
            id(main_scheduler).set_schedule_point(time_minutes, pwm_values, current_values);
        - logger.log:
            format: "Schedule point set at %02d:%02d for all channels"
            args: [ 'time_minutes / 60', 'time_minutes % 60' ]

    # Simplified 4-channel version for testing
    - service: set_schedule_point_4ch
      variables:
        time_minutes: int
        pwm_ch1: float
        pwm_ch2: float
        pwm_ch3: float
        pwm_ch4: float
        current_ch1: float
        current_ch2: float
        current_ch3: float
        current_ch4: float
      then:
        - lambda: |-
            std::vector<float> pwm_values = {pwm_ch1, pwm_ch2, pwm_ch3, pwm_ch4, 0, 0, 0, 0};
            std::vector<float> current_values = {current_ch1, current_ch2, current_ch3, current_ch4, 0, 0, 0, 0};
            id(main_scheduler).set_schedule_point(time_minutes, pwm_values, current_values);
        - logger.log:
            format: "Schedule point set at %02d:%02d for channels 1-4"
            args: [ 'time_minutes / 60', 'time_minutes % 60' ]

    # Remove a schedule point
    - service: remove_schedule_point
      variables:
        time_minutes: int
      then:
        - lambda: |-
            id(main_scheduler).remove_schedule_point(time_minutes);
        - logger.log:
            format: "Removed schedule point at %02d:%02d"
            args: [ 'time_minutes / 60', 'time_minutes % 60' ]

    # Clear all schedule points
    - service: clear_schedule
      then:
        - lambda: |-
            id(main_scheduler).clear_schedule();
        - logger.log: "Cleared all schedule points"

    # === Preset Management ===
    
    # Load a preset schedule
    - service: load_preset
      variables:
        preset_name: string
      then:
        - lambda: |-
            id(main_scheduler).load_preset(preset_name);
        - logger.log:
            format: "Loaded preset: %s"
            args: [ 'preset_name.c_str()' ]

    # Save current schedule as preset (custom presets saved in memory only)
    - service: save_preset
      variables:
        preset_name: string
      then:
        - lambda: |-
            id(main_scheduler).save_preset(preset_name);
        - logger.log:
            format: "Saved current schedule as preset: %s"
            args: [ 'preset_name.c_str()' ]

    # === Control Services ===
    
    # Enable/disable the scheduler
    - service: set_scheduler_enabled
      variables:
        enabled: bool
      then:
        - lambda: |-
            id(main_scheduler).set_enabled(enabled);
        - logger.log:
            format: "Scheduler %s"
            args: [ 'enabled ? "enabled" : "disabled"' ]

    # Get current scheduler status (logs current state)
    - service: get_scheduler_status
      then:
        - lambda: |-
            auto current_time = id(main_scheduler).get_current_time_minutes();
            auto values = id(main_scheduler).get_current_values();
            ESP_LOGI("main", "Scheduler Status - Enabled: %s, Time: %02d:%02d, Channels: %d", 
                     id(main_scheduler).is_enabled() ? "YES" : "NO",
                     current_time / 60, current_time % 60,
                     values.pwm_values.size());
            for (size_t i = 0; i < values.pwm_values.size() && i < 8; i++) {
              ESP_LOGI("main", "  Ch%d: PWM=%.1f%%, Current=%.2fA", 
                       (int)i+1, values.pwm_values[i], values.current_values[i]);
            }

    # === Data Export/Import Services ===
    
    # Export current schedule as JSON (to logs)
    - service: export_schedule
      then:
        - lambda: |-
            std::string json_output;
            id(main_scheduler).export_schedule_json(json_output);
            ESP_LOGI("main", "Schedule Export: %s", json_output.c_str());

    # Get schedule as JSON (logs the JSON data)
    - service: get_schedule_json
      then:
        - lambda: |-
            std::string json_output;
            id(main_scheduler).export_schedule_json(json_output);
            ESP_LOGI("main", "Schedule JSON Export: %s", json_output.c_str());

    # Import schedule from JSON
    - service: import_schedule_json
      variables:
        json_data: string
      then:
        - lambda: |-
            bool success = id(main_scheduler).import_schedule_json(json_data);
            if (success) {
              ESP_LOGI("main", "Schedule JSON import successful");
            } else {
              ESP_LOGW("main", "Schedule JSON import failed - invalid format");
            }

    # Force save schedule to flash
    - service: save_to_flash
      then:
        - lambda: |-
            id(main_scheduler).save_schedule_to_flash();
        - logger.log: "Schedule saved to flash memory"

    # Force reload schedule from flash
    - service: load_from_flash
      then:
        - lambda: |-
            id(main_scheduler).load_schedule_from_flash();
        - logger.log: "Schedule loaded from flash memory"

# === Status Sensors ===
# These sensors report the current state to Home Assistant

sensor:
  # Current scheduler time in minutes
  - platform: template
    name: "Scheduler Current Time Minutes"
    id: scheduler_time_minutes
    accuracy_decimals: 0
    unit_of_measurement: "min"
    lambda: |-
      return id(main_scheduler).get_current_time_minutes();
    update_interval: 60s

  # Current PWM values for monitoring (channel 1 as example)
  - platform: template
    name: "Scheduler PWM Channel 1"
    id: scheduler_pwm_ch1
    accuracy_decimals: 1
    unit_of_measurement: "%"
    lambda: |-
      auto values = id(main_scheduler).get_current_values();
      return values.pwm_values.size() > 0 ? values.pwm_values[0] : 0.0f;
    update_interval: 30s

  # Current values for monitoring (channel 1 as example)
  - platform: template
    name: "Scheduler Current Channel 1"
    id: scheduler_current_ch1
    accuracy_decimals: 2
    unit_of_measurement: "A"
    lambda: |-
      auto values = id(main_scheduler).get_current_values();
      return values.current_values.size() > 0 ? values.current_values[0] : 0.0f;
    update_interval: 30s

# === Entity Setup ===
# Connect scheduler to actual lights and number entities

esphome:
  on_boot:
    priority: 100  # Run after other components are set up
    then:
      - lambda: |-
          // Connect lights to scheduler (channels are 1-indexed in config, 0-indexed in code)
          if (id(lpwm1)) id(main_scheduler).add_light(0, id(lpwm1));
          if (id(lpwm2)) id(main_scheduler).add_light(1, id(lpwm2));
          if (id(lpwm3)) id(main_scheduler).add_light(2, id(lpwm3));
          if (id(lpwm4)) id(main_scheduler).add_light(3, id(lpwm4));
          if (id(lpwm5)) id(main_scheduler).add_light(4, id(lpwm5));
          if (id(lpwm6)) id(main_scheduler).add_light(5, id(lpwm6));
          if (id(lpwm7)) id(main_scheduler).add_light(6, id(lpwm7));
          if (id(lpwm8)) id(main_scheduler).add_light(7, id(lpwm8));
          
          // Connect current controls to scheduler
          if (id(current_1)) id(main_scheduler).add_current_control(0, id(current_1));
          if (id(current_2)) id(main_scheduler).add_current_control(1, id(current_2));
          if (id(current_3)) id(main_scheduler).add_current_control(2, id(current_3));
          if (id(current_4)) id(main_scheduler).add_current_control(3, id(current_4));
          if (id(current_5)) id(main_scheduler).add_current_control(4, id(current_5));
          if (id(current_6)) id(main_scheduler).add_current_control(5, id(current_6));
          if (id(current_7)) id(main_scheduler).add_current_control(6, id(current_7));
          if (id(current_8)) id(main_scheduler).add_current_control(7, id(current_8));
          
          // Connect max current controls to scheduler
          if (id(max_current_1)) id(main_scheduler).add_max_current_control(0, id(max_current_1));
          if (id(max_current_2)) id(main_scheduler).add_max_current_control(1, id(max_current_2));
          if (id(max_current_3)) id(main_scheduler).add_max_current_control(2, id(max_current_3));
          if (id(max_current_4)) id(main_scheduler).add_max_current_control(3, id(max_current_4));
          if (id(max_current_5)) id(main_scheduler).add_max_current_control(4, id(max_current_5));
          if (id(max_current_6)) id(main_scheduler).add_max_current_control(5, id(max_current_6));
          if (id(max_current_7)) id(main_scheduler).add_max_current_control(6, id(max_current_7));
          if (id(max_current_8)) id(main_scheduler).add_max_current_control(7, id(max_current_8));
          
          // Set current channels to their maximum configured values at boot
          if (id(current_1) && id(max_current_1)) {
            float max_val = id(max_current_1)->state;
            id(current_1)->publish_state(max_val);
            ESP_LOGI("main", "Set current_1 to max value: %.2fA", max_val);
          }
          if (id(current_2) && id(max_current_2)) {
            float max_val = id(max_current_2)->state;
            id(current_2)->publish_state(max_val);
            ESP_LOGI("main", "Set current_2 to max value: %.2fA", max_val);
          }
          if (id(current_3) && id(max_current_3)) {
            float max_val = id(max_current_3)->state;
            id(current_3)->publish_state(max_val);
            ESP_LOGI("main", "Set current_3 to max value: %.2fA", max_val);
          }
          if (id(current_4) && id(max_current_4)) {
            float max_val = id(max_current_4)->state;
            id(current_4)->publish_state(max_val);
            ESP_LOGI("main", "Set current_4 to max value: %.2fA", max_val);
          }
          if (id(current_5) && id(max_current_5)) {
            float max_val = id(max_current_5)->state;
            id(current_5)->publish_state(max_val);
            ESP_LOGI("main", "Set current_5 to max value: %.2fA", max_val);
          }
          if (id(current_6) && id(max_current_6)) {
            float max_val = id(max_current_6)->state;
            id(current_6)->publish_state(max_val);
            ESP_LOGI("main", "Set current_6 to max value: %.2fA", max_val);
          }
          if (id(current_7) && id(max_current_7)) {
            float max_val = id(max_current_7)->state;
            id(current_7)->publish_state(max_val);
            ESP_LOGI("main", "Set current_7 to max value: %.2fA", max_val);
          }
          if (id(current_8) && id(max_current_8)) {
            float max_val = id(max_current_8)->state;
            id(current_8)->publish_state(max_val);
            ESP_LOGI("main", "Set current_8 to max value: %.2fA", max_val);
          }
          
          ESP_LOGI("main", "Connected scheduler to all available lights and number entities");
          ESP_LOGI("main", "Set all current channels to their maximum configured values");

# === Control Entities ===

switch:
  # Global scheduler enable/disable
  - platform: template
    name: "Scheduler Enabled"
    id: scheduler_enable_switch
    lambda: |-
      return id(main_scheduler).is_enabled();
    turn_on_action:
      - lambda: |-
          id(main_scheduler).set_enabled(true);
    turn_off_action:
      - lambda: |-
          id(main_scheduler).set_enabled(false);

text_sensor:
  # Current time as human-readable string
  - platform: template
    name: "Scheduler Current Time"
    id: scheduler_time_display
    lambda: |-
      auto time_minutes = id(main_scheduler).get_current_time_minutes();
      char time_str[10];
      sprintf(time_str, "%02d:%02d", time_minutes / 60, time_minutes % 60);
      return std::string(time_str);
    update_interval: 60s